<?php

/**
 * @file
 * Allows site administrators to modify content.
 */

use Drupal\Core\Entity\ContentEntityInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Render\RenderContext;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Entity\ContentEntityType;
use Drupal\Core\Serialization\Yaml;
use Drupal\Core\Url;
use Drupal\content_sync\Form\ContentExportTrait;
use Drupal\content_sync\Form\ContentImportTrait;
use Drupal\Core\Queue\DatabaseQueue;

/**
 * Implements hook_help().
 */
function content_sync_help($route_name, RouteMatchInterface $route_match) : null|string|array {

  // Get path from route match.
  $path = preg_replace('/^' . preg_quote(base_path(), '/') . '/', '/', Url::fromRouteMatch($route_match)->setAbsolute(FALSE)->toString());
  if ($route_name !== 'system.modules_list' && !str_contains($route_name, 'help.page.content_sync') && !str_contains($path, '/content')) {
    return NULL;
  }

  /** @var \Drupal\content_sync\ContentSyncHelpManagerInterface $help_manager */
  $help_manager = \Drupal::service('content_sync.help_manager');
  if ($route_name === 'help.page.content_sync') {
    $build = $help_manager->buildIndex();
  }
  else {
    $build = $help_manager->buildHelp($route_name, $route_match);
  }

  if ($build) {
    $renderer = \Drupal::service('renderer');
    $config = \Drupal::config('content_sync.settings');
    $renderer->addCacheableDependency($build, $config);
    return $build;
  }

  return NULL;
}

/**
 * Implements hook_theme().
 */
function content_sync_theme() {
  $info = [
    'content_sync_help' => [
      'variables' => ['info' => []],
    ],
    'content_sync_message' => [
      'render element' => 'element',
    ],
  ];

  // Since any rendering of a content_sync is going to require
  // 'content_sync.theme.inc' we are going to just add it to every template.
  foreach ($info as &$template) {
    $template['file'] = 'includes/content_sync.theme.inc';
  }
  return $info;
}

/**
 * Implements hook_file_download().
 */
function content_sync_file_download(string $uri) : array|int {
  /** @var \Drupal\Core\StreamWrapper\StreamWrapperManagerInterface $stream_wrapper_manager */
  $stream_wrapper_manager = \Drupal::service('stream_wrapper_manager');
  $scheme = $stream_wrapper_manager::getScheme($uri);
  $target = $stream_wrapper_manager::getTarget($uri);
  if ($scheme === 'temporary' && $target === 'content.tar.gz') {
    if (\Drupal::currentUser()->hasPermission('export content')) {
      $request = \Drupal::request();
      $date = DateTime::createFromFormat('U', $request->server->get('REQUEST_TIME'));
      $date_string = $date->format('Y-m-d-H-i');
      $hostname = str_replace('.', '-', $request->getHttpHost());
      $filename = 'content-' . $hostname . '-' . $date_string . '.tar.gz';
      $disposition = 'attachment; filename="' . $filename . '"';
      return [
        'Content-disposition' => $disposition,
      ];
    }
    return -1;
  }
}

/**
 * Returns the path of a content directory.
 *
 * Content directories are configured using $content_directories in
 * settings.php.
 *
 * @param string $type
 *   The type of content directory to return.
 *
 * @return string
 *   The content directory path.
 *
 * @throws \Exception
 */
function content_sync_get_content_directory(string $type) : ?string {
  // phpcs:ignore Drupal.NamingConventions.ValidGlobal.GlobalUnderScore
  global $content_directories;

  if ($type == 'sync' &&
    !isset($content_directories['sync'])
    && isset($content_directories['staging'])) {
    $type = 'staging';
  }

  if (!empty($content_directories[$type])) {
    return $content_directories[$type];
  }

  \Drupal::messenger()->addError("The content directory type '$type' does not exist");
}

/**
 * Implements hook_entity_update().
 *
 * Keep the content snapshot table synced.
 */
function content_sync_entity_update(EntityInterface $entity) : void {
  $renderer = \Drupal::service('renderer');
  $context = new RenderContext();

  // XXX: Suppress leaking cached metadata here as its not being used in the
  // response whatsoever. The normalizers inside of this call generated
  // cacheable metadata but there is no needed context as this is running on
  // an entity update and has nothing to do with front-end rendering.
  $renderer->executeInRenderContext($context, function () use ($entity) {
    // Get submitted values.
    $entity_type = $entity->getEntityTypeId();
    $entity_bundle = $entity->bundle();
    $entity_id = $entity->id();

    // Validate that it is a Content Entity.
    $entityTypeManager = \Drupal::entityTypeManager();
    $instances = $entityTypeManager->getDefinitions();
    if (isset($instances[$entity_type]) && $instances[$entity_type] instanceof ContentEntityType) {
      $reloaded_entity = $entityTypeManager->getStorage($entity_type)
        ->load($entity_id);
      assert($reloaded_entity instanceof ContentEntityInterface);
      if (!$reloaded_entity) {
        \Drupal::logger('content_sync')->warning('Failed to (re)load entity during update hook: {type}, {id}', [
          'type' => $entity_type,
          'id' => $entity_id,
        ]);
        return;
      }
      // Generate the YAML file.
      $serializer_context = [];
      /** @var \Drupal\content_sync\Exporter\ContentExporter $exporter */
      $exporter = \Drupal::service('content_sync.exporter');
      $exported_entity = $exporter->exportEntity($reloaded_entity, $serializer_context);
      // Create the name.
      $name = $entity_type . '.' . $entity_bundle . '.' . $reloaded_entity->uuid();
      // Insert/Update Data.
      /** @var \Drupal\content_sync\Content\DatabaseStorage $activeStorage */
      $activeStorage = \Drupal::service('content.storage.active');
      $activeStorage->contentSyncWrite($name, Yaml::decode($exported_entity), $entity_type . "." . $entity_bundle);
      // Invalidate the CS Cache of the entity.
      \Drupal::cache('content')->invalidate($entity_type . "." . $entity_bundle . ":" . $name);
    }
  });
}

/**
 * Implements hook_entity_insert().
 *
 * Keep the content snapshot table synced.
 */
function content_sync_entity_insert(EntityInterface $entity) : void {
  content_sync_entity_update($entity);
}

/**
 * Implements hook_entity_delete().
 *
 * Keep the content snapshot table synced.
 */
function content_sync_entity_delete(EntityInterface $entity) : void {
  // Get submitted values.
  $entity_type = $entity->getEntityTypeId();
  $entity_bundle = $entity->Bundle();
  $entity_uuid = $entity->uuid();

  // Validate that it is a Content Entity.
  $entityTypeManager = \Drupal::entityTypeManager();
  $instances = $entityTypeManager->getDefinitions();
  if (isset($instances[$entity_type]) && $instances[$entity_type] instanceof ContentEntityType) {
    // Update the data for diff.
    $name = $entity_type . '.' . $entity_bundle . '.' . $entity_uuid;
    // Delete Data.
    /** @var \Drupal\content_sync\Content\DatabaseStorage $activeStorage */
    $activeStorage = \Drupal::service('content.storage.active');
    $activeStorage->contentSyncDelete($name);
    // Invalidate the CS Cache of the entity.
    \Drupal::cache('content')->invalidate($entity_type . '.' . $entity_bundle . ':' . $name);
  }
}

/**
 * Implements hook_cron().
 */
function content_sync_cron() : void {

  // Adapted from the drupal_batch queue garbage collection to clean up our
  // multiple queues.
  // @see DatabaseQueue::garbageCollection()
  $prefixes = [
    ContentExportTrait::getExportQueuePrefix(),
    ContentImportTrait::getDeleteQueuePrefix(),
    ContentImportTrait::getSyncQueuePrefix(),
  ];

  $conn = \Drupal::database();
  $query = $conn->delete(DatabaseQueue::TABLE_NAME)
    ->condition('created', \Drupal::time()->getRequestTime() - 864000, '<');

  $or = $query->orConditionGroup();
  foreach ($prefixes as $prefix) {
    $or->condition('name', $conn->escapeLike($prefix) . '%', 'LIKE');
  }
  $query->condition($or)->execute();

}
